{
  "hash": "730db9d2726aca93f4f60eedc5900ded",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"A Beginner's Guide to pandas & polars\"\ndate: \"2025-05-05\"\ncategories: [python]\nimage: \"thumbnail.png\"\nother-links:\n  - text: Comment on GitHub\n    icon: chat\n    href: https://github.com/rnd195/rnd195.github.io-comments/issues/3\n    target: _blank\nexecute:\n  freeze: true\n---\n\nThis guide will help you start learning `polars` by showcasing analogous code snippets from `pandas`.\n\n![](thumbnail.png){fig-alt=\"Picture of text that says import pandas as pd and import polars as pl\"}\n\nIn recent years, `polars`[^pl-style] is becoming increasingly popular in the data science community (more than 33k stars on GitHub as of May 2025[^popularity]). According to the author of `polars`, Ritchie Vink, the package's API is \"consistent and strict,\" and its focus is on maximizing single machine performance[^pl-jb] which perhaps explains some of the library's appeal. From my experience, `polars` has been a major time saver, especially in data-intensive computations. However, I think that it is perfectly reasonable to prefer `pandas` for some tasks (like quick data visualization), and I am glad that this competition is pushing the field forward.\n\nIn this post, I wrote down some of the most common operations in `pandas` and their equivalents in `polars` to help you get acquainted with the package (and to help myself remember). Please, note that this guide / cheat sheet may not be exhaustive and in some cases, there might be additional ways to achieve the same goal. Feel free to let me know [in the comments](https://github.com/rnd195/rnd195.github.io-comments/issues/3).\n\nThis is a runnable Quarto document, so first, let's load the packages.\n\n::: {#814a78ba .cell execution_count=1}\n``` {.python .cell-code}\nimport pandas as pd\nimport numpy as np\nimport polars as pl\nfrom datetime import date, timedelta, datetime\n```\n:::\n\n\n## Load data\n\nWe'll be working with my Wizard Shop Dataset[^dataset] which was specifically crafted for introductory data analysis. It consists of three tables:\n\n\n- `wizard_shop_inventory.csv`: A list of products with prices, item quality, and other attributes.\n\n- `magical_items_info.csv`: A small table with typical price, quality, and where the item is typically found.\n\n- `items_prices_timeline.csv`: Average daily prices of each product category.\n\n\nLet's load the data.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nAs we can see, the syntax is the same in both packages except for parsing dates.\n\n::: {#0228f36f .cell execution_count=2}\n``` {.python .cell-code}\ndata_url = \"https://raw.githubusercontent.com/rnd195/wizard-shop-dataset/refs/heads/main/data/\"\n\ndf_pd = pd.read_csv(data_url + \"wizard_shop_inventory.csv\")\ninfo_pd = pd.read_csv(data_url + \"magical_items_info.csv\")\nprices_pd = pd.read_csv(\n    data_url + \"items_prices_timeline.csv\", \n    parse_dates=[\"date\"]\n)\n```\n:::\n\n\n## 2️⃣ polars\n\nAs we can see, the syntax is the same in both packages except for parsing dates.\n\n::: {#30ca7678 .cell execution_count=3}\n``` {.python .cell-code}\ndata_url = \"https://raw.githubusercontent.com/rnd195/wizard-shop-dataset/refs/heads/main/data/\"\n\ndf_pl = pl.read_csv(data_url + \"wizard_shop_inventory.csv\")\ninfo_pl = pl.read_csv(data_url + \"magical_items_info.csv\")\nprices_pl = pl.read_csv(\n    data_url + \"items_prices_timeline.csv\", \n    try_parse_dates=True\n)\n```\n:::\n\n\n:::\n\n## Take a peek\n\nSometimes, we want to take a quick look at the data. The methods `.sample()`, `.head()`, and `.tail()` all work in both packages.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nThe `df` DataFrame contains all the products the wizard shopkeeper sells—items like potions, amulets, or cloaks. \n\n::: {#aa5c03cb .cell execution_count=4}\n``` {.python .cell-code}\ndf_pd.sample(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=4}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>item</th>\n      <th>price</th>\n      <th>magical_power</th>\n      <th>quality</th>\n      <th>in_stock</th>\n      <th>found_in</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>426</th>\n      <td>427</td>\n      <td>cloak</td>\n      <td>630.5</td>\n      <td>298.183</td>\n      <td>0</td>\n      <td>True</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>299</th>\n      <td>300</td>\n      <td>staff</td>\n      <td>2124.0</td>\n      <td>772.533</td>\n      <td>7</td>\n      <td>True</td>\n      <td>NaN</td>\n    </tr>\n    <tr>\n      <th>42</th>\n      <td>43</td>\n      <td>amulet</td>\n      <td>1076.0</td>\n      <td>465.399</td>\n      <td>9</td>\n      <td>True</td>\n      <td>dungeon</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `info` table contains information about the typical attributes of these items.\n\n::: {#3ef6482f .cell execution_count=5}\n``` {.python .cell-code}\ninfo_pd.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>item</th>\n      <th>typical_price</th>\n      <th>typical_quality</th>\n      <th>typically_found_in</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>amulet</td>\n      <td>1000</td>\n      <td>9</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>potion</td>\n      <td>50</td>\n      <td>7</td>\n      <td>village</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>cloak</td>\n      <td>500</td>\n      <td>4</td>\n      <td>city</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\nThe `prices` DataFrame contains the daily average price of each item in the fantasy world's economy in the magical year of 2025.\n\n::: {#a75ec98a .cell execution_count=6}\n``` {.python .cell-code}\nprices_pd.tail(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=6}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>date</th>\n      <th>amulet</th>\n      <th>potion</th>\n      <th>cloak</th>\n      <th>staff</th>\n      <th>scroll</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>362</th>\n      <td>2025-12-29</td>\n      <td>742.21</td>\n      <td>44.70</td>\n      <td>648.72</td>\n      <td>971.90</td>\n      <td>731.69</td>\n    </tr>\n    <tr>\n      <th>363</th>\n      <td>2025-12-30</td>\n      <td>802.06</td>\n      <td>48.99</td>\n      <td>446.10</td>\n      <td>1711.04</td>\n      <td>728.60</td>\n    </tr>\n    <tr>\n      <th>364</th>\n      <td>2025-12-31</td>\n      <td>957.94</td>\n      <td>64.08</td>\n      <td>503.88</td>\n      <td>2899.72</td>\n      <td>829.59</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\nThe `df` DataFrame contains all the products the wizard shopkeeper sells—items like potions, amulets, or cloaks. \n\n::: {#ec1b1fae .cell execution_count=7}\n``` {.python .cell-code}\ndf_pl.sample(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=7}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 7)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>id</th><th>item</th><th>price</th><th>magical_power</th><th>quality</th><th>in_stock</th><th>found_in</th></tr><tr><td>i64</td><td>str</td><td>f64</td><td>f64</td><td>i64</td><td>bool</td><td>str</td></tr></thead><tbody><tr><td>376</td><td>&quot;scroll&quot;</td><td>1039.5</td><td>424.913</td><td>4</td><td>true</td><td>&quot;dungeon&quot;</td></tr><tr><td>90</td><td>&quot;potion&quot;</td><td>64.35</td><td>93.7195</td><td>3</td><td>true</td><td>&quot;dungeon&quot;</td></tr><tr><td>125</td><td>&quot;potion&quot;</td><td>54.05</td><td>108.9175</td><td>8</td><td>true</td><td>&quot;dungeon&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nThe `info` table contains information about the typical attributes of these items.\n\n::: {#71c4bfa7 .cell execution_count=8}\n``` {.python .cell-code}\ninfo_pl.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=8}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 4)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>item</th><th>typical_price</th><th>typical_quality</th><th>typically_found_in</th></tr><tr><td>str</td><td>i64</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>&quot;amulet&quot;</td><td>1000</td><td>9</td><td>&quot;dungeon&quot;</td></tr><tr><td>&quot;potion&quot;</td><td>50</td><td>7</td><td>&quot;village&quot;</td></tr><tr><td>&quot;cloak&quot;</td><td>500</td><td>4</td><td>&quot;city&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\nThe `prices` DataFrame contains the daily average price of each item in the fantasy world's economy in the magical year of 2025.\n\n::: {#91f809ba .cell execution_count=9}\n``` {.python .cell-code}\nprices_pl.tail(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>date</th><th>amulet</th><th>potion</th><th>cloak</th><th>staff</th><th>scroll</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2025-12-29</td><td>742.21</td><td>44.7</td><td>648.72</td><td>971.9</td><td>731.69</td></tr><tr><td>2025-12-30</td><td>802.06</td><td>48.99</td><td>446.1</td><td>1711.04</td><td>728.6</td></tr><tr><td>2025-12-31</td><td>957.94</td><td>64.08</td><td>503.88</td><td>2899.72</td><td>829.59</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n\n## Subset a DataFrame\n\n### Columns\n\n\n#### Select a column by name\n\nThere are several ways to select a single column in both `pandas` and `polars`. Note that some of the calls return a Series while others return a DataFrame.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#bf83cb8b .cell execution_count=10}\n``` {.python .cell-code}\ndf_pd[\"price\"]        # -> returns Series of shape (500,)\ndf_pd[[\"price\"]]      # -> returns DataFrame of shape (500, 1)\ndf_pd.price           # -> returns Series of shape (500,)\ndf_pd.loc[:, \"price\"] # -> returns Series of shape (500,)\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#408b487e .cell execution_count=11}\n``` {.python .cell-code}\ndf_pl[\"price\"]                # -> returns Series of shape (500,)\ndf_pl[:, \"price\"]             # -> returns Series of shape (500,)\ndf_pl.select(\"price\")         # -> returns DataFrame of shape (500, 1)\ndf_pl.select(pl.col(\"price\")) # -> returns DataFrame of shape (500, 1)\n```\n:::\n\n\n:::\n\n#### Select multiple columns by name\n\nBelow are several alternatives for selecting columns.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#9751ea55 .cell execution_count=12}\n``` {.python .cell-code}\ndf_pd[[\"item\", \"price\"]]\ndf_pd.loc[:, [\"item\", \"price\"]]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#97c9b488 .cell execution_count=13}\n``` {.python .cell-code}\ndf_pl[[\"item\", \"price\"]]\ndf_pl[:, [\"item\", \"price\"]]\ndf_pl[\"item\", \"price\"]\ndf_pl.select([\"item\", \"price\"])\ndf_pl.select(pl.col(\"item\", \"price\"))\n```\n:::\n\n\n:::\n\n#### Slice columns by range\n\nInstead of selecting columns by name, we can write their positions in the DataFrame.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#00342e8a .cell execution_count=14}\n``` {.python .cell-code}\ndf_pd.iloc[:, 5:7]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#4ecc36cb .cell execution_count=15}\n``` {.python .cell-code}\ndf_pl[:, 5:7]\n```\n:::\n\n\n:::\n\n\n\n#### Slice columns by name\n\nIt's also possible to select a range of columns by name. The resulting DataFrame will contain the first and the last selected column as well as any columns in-between.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#e6e33642 .cell execution_count=16}\n``` {.python .cell-code}\ndf_pd.loc[:, \"in_stock\":\"found_in\"]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#07187de0 .cell execution_count=17}\n``` {.python .cell-code}\ndf_pl[:, \"in_stock\":\"found_in\"]\n```\n:::\n\n\n:::\n\n#### Filter columns using Bools\n\nWe can pass a list of True/False values to select specific columns. The length of this list needs to be the same as the number of columns in the DataFrame. For instance, `df_pd`/`df_pl` contains 7 columns. Thus, one possible list of True/False values may look like this: `[True, False, True, False, True, True, True]`.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#1bb9e477 .cell execution_count=18}\n``` {.python .cell-code}\n# Return all columns containing the substring \"price\"\ndf_pd.loc[:, [\"price\" in col for col in df_pd.columns]]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#0a786108 .cell execution_count=19}\n``` {.python .cell-code}\n# Return all columns containing the substring \"price\"\ndf_pl[:, [\"price\" in col for col in df_pl.columns]]\n```\n:::\n\n\n:::\n\n\n### Rows\n\n#### Select row by index label \n\nIn case the index is, for example, `datetime` or `str`, it is possible to select rows by the index label. However, this is not applicable in `polars` since [`polars` treats the index differently](https://docs.pola.rs/user-guide/migration/pandas/) than `pandas`.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#0fe19db7 .cell execution_count=20}\n``` {.python .cell-code}\nprices_pd = prices_pd.set_index(\"date\")\nprices_pd.loc[\"2025-01-05\"]\n```\n\n::: {.cell-output .cell-output-display execution_count=20}\n```\namulet     996.24\npotion      49.65\ncloak      497.42\nstaff     2643.03\nscroll    1096.03\nName: 2025-01-05 00:00:00, dtype: float64\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\n::: {#66f85b35 .cell execution_count=21}\n``` {.python .cell-code}\n# Not applicable in polars\n# Below is a call that outputs a similar result\nprices_pl.filter(pl.col(\"date\") == date(2025, 1, 5))\n```\n\n::: {.cell-output .cell-output-display execution_count=21}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (1, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>date</th><th>amulet</th><th>potion</th><th>cloak</th><th>staff</th><th>scroll</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2025-01-05</td><td>996.24</td><td>49.65</td><td>497.42</td><td>2643.03</td><td>1096.03</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n#### Select a single row by integer position\n\nBoth `pandas` and `polars` support selecting a single row using its integer position.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#60e030fe .cell execution_count=22}\n``` {.python .cell-code}\ndf_pd.iloc[4] # -> returns a Series\ndf_pd[4:5]    # -> returns a DataFrame\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#3ffef09b .cell execution_count=23}\n``` {.python .cell-code}\ndf_pl[4] \ndf_pl[4:5]\ndf_pl[4, :] # -> all three of these return a DataFrame\n```\n:::\n\n\n:::\n\n#### Slice rows by integer range\n\nLikewise, both `pandas` and `polars` support selecting rows using a range of integers.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#f6e94632 .cell execution_count=24}\n``` {.python .cell-code}\ndf_pd.iloc[0:5]\ndf_pd[0:5]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#59323fc9 .cell execution_count=25}\n``` {.python .cell-code}\ndf_pl[0:5]\ndf_pl[0:5, :]\n```\n:::\n\n\n:::\n\n#### Filter rows using Bools\n\nWe can pass a Series (or a similar object) containing True/False values to subset the DataFrame.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#c020c2da .cell execution_count=26}\n``` {.python .cell-code}\n# Get products with price over 1000\ndf_pd[df_pd[\"price\"] > 1000]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#650ba9bc .cell execution_count=27}\n``` {.python .cell-code}\n# Get products with price over 1000\ndf_pl.filter(df_pl[\"price\"] > 1000)\ndf_pl.filter(pl.col(\"price\") > 1000)\n```\n:::\n\n\n:::\n\n\n\n## Creating new columns\n\n#### New empty column\n\nSometimes, it might make sense to create a new column in a DataFrame and fill it with NA values. I think of it as \"reserving\" the column for values that will be put into the column later. There are several ways to achieve this in both packages.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nMissing values in `pandas`: depends on the datatype. Consider using `None` or `np.nan`. Note that `pd.NA` is [still experimental](https://pandas.pydata.org/docs/user_guide/missing_data.html#na-semantics).\n\n::: {#88036404 .cell execution_count=28}\n``` {.python .cell-code}\n# Is any item in the wizard's shop cursed? We don't know => NA\ndf_pd[\"is_cursed\"] = np.nan\ndf_pd = df_pd.assign(is_cursed=np.nan)\ndf_pd = df_pd.assign(**{\"is_cursed\": np.nan})\ndf_pd.loc[:, \"is_cursed\"] = np.nan\n```\n:::\n\n\n## 2️⃣ polars\n\nMissing values in `polars`: `None`, represented as `null`.\n\n::: {#8ee32f5e .cell execution_count=29}\n``` {.python .cell-code}\n# Is any item in the wizard's shop cursed? We don't know => NA\ndf_pl = df_pl.with_columns(is_cursed=None)\ndf_pl = df_pl.with_columns(is_cursed=pl.lit(None))\ndf_pl = df_pl.with_columns(pl.lit(None).alias(\"is_cursed\"))\n```\n:::\n\n\n:::\n\n#### Transform an existing column\n\nApply any function to an existing column in a DataFrame and write it as a new column.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nSome options for transforming columns in `pandas`: `.transform()`, `.apply()`, calling a `numpy` function on the Series…\n\n::: {#fccdac10 .cell execution_count=30}\n``` {.python .cell-code}\n# Take the logarithm of the price column\ndf_pd[\"log_price\"] = df_pd[\"price\"].transform(\"log\")\ndf_pd[\"log_price\"] = df_pd[\"price\"].apply(np.log)\ndf_pd[\"log_price\"] = np.log(df_pd[\"price\"])\n```\n:::\n\n\n## 2️⃣ polars\n\nTransforming columns in `polars`: use the `.with_columns(...)` method.\n\n::: {#b7746f26 .cell execution_count=31}\n``` {.python .cell-code}\n# Take the logarithm of the price column\ndf_pl = df_pl.with_columns(pl.col(\"price\").log().alias(\"log_price\"))\ndf_pl = df_pl.with_columns(log_price=pl.col(\"price\").log())\ndf_pl = df_pl.with_columns(df_pl[\"price\"].log().alias(\"log_price\"))\n```\n:::\n\n\n:::\n\n\n\n## Boolean filters\n\nUse set operations to filter the DataFrame based on predefined conditions.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#b7e2e631 .cell execution_count=32}\n``` {.python .cell-code}\n# AND operator\ndf_pd[(df_pd[\"price\"] > 500) & (df_pd[\"price\"] < 2000)]\n# OR operator\ndf_pd[(df_pd[\"price\"] >= 500) | (df_pd[\"item\"] != \"scroll\")]\n# Inverse\ndf_pd[~df_pd[\"in_stock\"]]\n# True if a value matches any of the specified values, else False\ndf_pd[df_pd[\"item\"].isin([\"staff\", \"potion\"])]\n# Is not NA... there's also .dropna() \ndf_pd[~df_pd[\"found_in\"].isna()]\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#a79ef4f9 .cell execution_count=33}\n``` {.python .cell-code}\n# AND operator\ndf_pl.filter((pl.col(\"price\") > 500) & (pl.col(\"price\") < 2000))\n# OR operator\ndf_pl.filter((pl.col(\"price\") >= 500) | (pl.col(\"item\") != \"scroll\"))\n# Inverse\ndf_pl.filter(~pl.col(\"in_stock\"))\n# True if a value matches any of the specified values, else False\ndf_pl.filter(pl.col(\"item\").is_in([\"staff\", \"potion\"]))\n# Is not NA... consider also .is_not_null()\ndf_pl.filter(~pl.col(\"found_in\").is_null())\n```\n:::\n\n\n:::\n\n## Replacing values in row slices\n\nLet me explain this with an example relating to the dataset at hand. We are looking at the inventory of a particular wizard shop. In this magical universe, let's suppose that we learn that every item with `magical_power` over 900 is cursed. There might be other reasons why an item is cursed, but these reasons are unknown to us.\n\nWhat we can do is to filter the DataFrame to display only items with `magical_power` over 900 and using this filter, we write `True` to the `is_cursed` column for every row satisfying this condition.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nLabel all items with `magical_power` over 900 as cursed.\n\n::: {#9e5dd64d .cell execution_count=34}\n``` {.python .cell-code}\n# A column full of NAs should be cast as \"object\" first\ndf_pd[\"is_cursed\"] = df_pd[\"is_cursed\"].astype(\"object\")\n\ndf_pd.loc[df_pd[\"magical_power\"] > 900, \"is_cursed\"] = True\ndf_pd.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=34}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>item</th>\n      <th>price</th>\n      <th>magical_power</th>\n      <th>quality</th>\n      <th>in_stock</th>\n      <th>found_in</th>\n      <th>is_cursed</th>\n      <th>log_price</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>amulet</td>\n      <td>915.0</td>\n      <td>402.961</td>\n      <td>9</td>\n      <td>True</td>\n      <td>dungeon</td>\n      <td>NaN</td>\n      <td>6.818924</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>staff</td>\n      <td>2550.0</td>\n      <td>933.978</td>\n      <td>2</td>\n      <td>False</td>\n      <td>dungeon</td>\n      <td>True</td>\n      <td>7.843849</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>potion</td>\n      <td>62.2</td>\n      <td>129.897</td>\n      <td>5</td>\n      <td>True</td>\n      <td>city</td>\n      <td>NaN</td>\n      <td>4.130355</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\nLabel all items with `magical_power` over 900 as cursed.\n\n::: {#dd3c7ba5 .cell execution_count=35}\n``` {.python .cell-code}\ndf_pl = df_pl.with_columns(\n    pl.when(pl.col(\"magical_power\") > 900)\n    .then(pl.lit(True))\n    .otherwise(pl.col(\"is_cursed\"))\n    .alias(\"is_cursed\")\n)\ndf_pl.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=35}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 9)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>id</th><th>item</th><th>price</th><th>magical_power</th><th>quality</th><th>in_stock</th><th>found_in</th><th>is_cursed</th><th>log_price</th></tr><tr><td>i64</td><td>str</td><td>f64</td><td>f64</td><td>i64</td><td>bool</td><td>str</td><td>bool</td><td>f64</td></tr></thead><tbody><tr><td>1</td><td>&quot;amulet&quot;</td><td>915.0</td><td>402.961</td><td>9</td><td>true</td><td>&quot;dungeon&quot;</td><td>null</td><td>6.818924</td></tr><tr><td>2</td><td>&quot;staff&quot;</td><td>2550.0</td><td>933.978</td><td>2</td><td>false</td><td>&quot;dungeon&quot;</td><td>true</td><td>7.843849</td></tr><tr><td>3</td><td>&quot;potion&quot;</td><td>62.2</td><td>129.897</td><td>5</td><td>true</td><td>&quot;city&quot;</td><td>null</td><td>4.130355</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n## Create a copy\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#de61bd5f .cell execution_count=36}\n``` {.python .cell-code}\ndf_pd_temp = df_pd.copy()\n```\n:::\n\n\n## 2️⃣ polars\n\nIn `polars`, copying or *cloning* (`.clone()` method) may not be necessary.[^clone]\n\n::: {#5afa439c .cell execution_count=37}\n``` {.python .cell-code}\ndf_pl_temp = df_pl\n```\n:::\n\n\n:::\n\n\n## Joining data\n\n### Inner join\n\nThe `info_pd` / `info_pl` table contains typical information (e.g., typical price) about each item in the fantasy universe this dataset was sourced from. Naturally, the shopkeeper has no incentive to provide this information in the original data. However, we can add the information from the info table to the main table ourselves. \n\nIn our case, we can use an \"inner join\" and match the items using the `item` column as long as \n\n- both tables contain this column,\n\n- and the column itself serves the same purpose in both tables.\n\n\nIf there would be an additional item in the shopkeeper's inventory for which we wouldn't have data in the `info` table, we may consider using an \"outer join.\" For a review of joins consider reading the following [Wiki article](https://en.wikipedia.org/wiki/Join_(SQL)).\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#df61714e .cell execution_count=38}\n``` {.python .cell-code}\ninfo_pd\n```\n\n::: {.cell-output .cell-output-display execution_count=38}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>item</th>\n      <th>typical_price</th>\n      <th>typical_quality</th>\n      <th>typically_found_in</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>amulet</td>\n      <td>1000</td>\n      <td>9</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>potion</td>\n      <td>50</td>\n      <td>7</td>\n      <td>village</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>cloak</td>\n      <td>500</td>\n      <td>4</td>\n      <td>city</td>\n    </tr>\n    <tr>\n      <th>3</th>\n      <td>staff</td>\n      <td>2000</td>\n      <td>5</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>4</th>\n      <td>scroll</td>\n      <td>900</td>\n      <td>2</td>\n      <td>dungeon</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n::: {#1abb3d2d .cell execution_count=39}\n``` {.python .cell-code}\ndf_full_pd = pd.merge(left=df_pd, right=info_pd, how=\"inner\", on=\"item\")\ndf_full_pd.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=39}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>id</th>\n      <th>item</th>\n      <th>price</th>\n      <th>magical_power</th>\n      <th>quality</th>\n      <th>in_stock</th>\n      <th>found_in</th>\n      <th>is_cursed</th>\n      <th>log_price</th>\n      <th>typical_price</th>\n      <th>typical_quality</th>\n      <th>typically_found_in</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>0</th>\n      <td>1</td>\n      <td>amulet</td>\n      <td>915.0</td>\n      <td>402.961</td>\n      <td>9</td>\n      <td>True</td>\n      <td>dungeon</td>\n      <td>NaN</td>\n      <td>6.818924</td>\n      <td>1000</td>\n      <td>9</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>1</th>\n      <td>2</td>\n      <td>staff</td>\n      <td>2550.0</td>\n      <td>933.978</td>\n      <td>2</td>\n      <td>False</td>\n      <td>dungeon</td>\n      <td>True</td>\n      <td>7.843849</td>\n      <td>2000</td>\n      <td>5</td>\n      <td>dungeon</td>\n    </tr>\n    <tr>\n      <th>2</th>\n      <td>3</td>\n      <td>potion</td>\n      <td>62.2</td>\n      <td>129.897</td>\n      <td>5</td>\n      <td>True</td>\n      <td>city</td>\n      <td>NaN</td>\n      <td>4.130355</td>\n      <td>50</td>\n      <td>7</td>\n      <td>village</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\n::: {#0f2793cc .cell execution_count=40}\n``` {.python .cell-code}\ninfo_pl\n```\n\n::: {.cell-output .cell-output-display execution_count=40}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 4)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>item</th><th>typical_price</th><th>typical_quality</th><th>typically_found_in</th></tr><tr><td>str</td><td>i64</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>&quot;amulet&quot;</td><td>1000</td><td>9</td><td>&quot;dungeon&quot;</td></tr><tr><td>&quot;potion&quot;</td><td>50</td><td>7</td><td>&quot;village&quot;</td></tr><tr><td>&quot;cloak&quot;</td><td>500</td><td>4</td><td>&quot;city&quot;</td></tr><tr><td>&quot;staff&quot;</td><td>2000</td><td>5</td><td>&quot;dungeon&quot;</td></tr><tr><td>&quot;scroll&quot;</td><td>900</td><td>2</td><td>&quot;dungeon&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n::: {#2dfce4ac .cell execution_count=41}\n``` {.python .cell-code}\ndf_full_pl = df_pl.join(other=info_pl, on=\"item\", how=\"inner\")\ndf_full_pl.head(3)\n```\n\n::: {.cell-output .cell-output-display execution_count=41}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (3, 12)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>id</th><th>item</th><th>price</th><th>magical_power</th><th>quality</th><th>in_stock</th><th>found_in</th><th>is_cursed</th><th>log_price</th><th>typical_price</th><th>typical_quality</th><th>typically_found_in</th></tr><tr><td>i64</td><td>str</td><td>f64</td><td>f64</td><td>i64</td><td>bool</td><td>str</td><td>bool</td><td>f64</td><td>i64</td><td>i64</td><td>str</td></tr></thead><tbody><tr><td>1</td><td>&quot;amulet&quot;</td><td>915.0</td><td>402.961</td><td>9</td><td>true</td><td>&quot;dungeon&quot;</td><td>null</td><td>6.818924</td><td>1000</td><td>9</td><td>&quot;dungeon&quot;</td></tr><tr><td>2</td><td>&quot;staff&quot;</td><td>2550.0</td><td>933.978</td><td>2</td><td>false</td><td>&quot;dungeon&quot;</td><td>true</td><td>7.843849</td><td>2000</td><td>5</td><td>&quot;dungeon&quot;</td></tr><tr><td>3</td><td>&quot;potion&quot;</td><td>62.2</td><td>129.897</td><td>5</td><td>true</td><td>&quot;city&quot;</td><td>null</td><td>4.130355</td><td>50</td><td>7</td><td>&quot;village&quot;</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n\n### Concatenate by rows\n\nConcatenating by rows stacks two tables on top of each other like bricks.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#36862fc8 .cell execution_count=42}\n``` {.python .cell-code}\nnew_price = pd.DataFrame(\n    {\n        \"amulet\": [1005.1],\n        \"potion\": [55.32],\n        \"cloak\": [550.06],\n        \"staff\": [1500.15],\n        \"scroll\": [1123.06]\n    },\n    index=[datetime(2026, 1, 1)]\n)\npd.concat([prices_pd, new_price]).tail(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=42}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>amulet</th>\n      <th>potion</th>\n      <th>cloak</th>\n      <th>staff</th>\n      <th>scroll</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-12-31</th>\n      <td>957.94</td>\n      <td>64.08</td>\n      <td>503.88</td>\n      <td>2899.72</td>\n      <td>829.59</td>\n    </tr>\n    <tr>\n      <th>2026-01-01</th>\n      <td>1005.10</td>\n      <td>55.32</td>\n      <td>550.06</td>\n      <td>1500.15</td>\n      <td>1123.06</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\n::: {#5e36f195 .cell execution_count=43}\n``` {.python .cell-code}\nnew_price = pl.DataFrame({\n    \"date\": date(2026, 1, 1),\n    \"amulet\": 1005.1,\n    \"potion\": 55.32,\n    \"cloak\": 550.06,\n    \"staff\": 1500.15,\n    \"scroll\": 1123.06\n})\npl.concat([prices_pl, new_price]).tail(2)\n```\n\n::: {.cell-output .cell-output-display execution_count=43}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (2, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>date</th><th>amulet</th><th>potion</th><th>cloak</th><th>staff</th><th>scroll</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2025-12-31</td><td>957.94</td><td>64.08</td><td>503.88</td><td>2899.72</td><td>829.59</td></tr><tr><td>2026-01-01</td><td>1005.1</td><td>55.32</td><td>550.06</td><td>1500.15</td><td>1123.06</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n\n\n## Quick plotting\n\nDataFrames in `pandas` can be quickly plotted using the `.plot()` method. While `polars` also contains quick plotting capabilities, I prefer converting the DataFrame to `pandas`. For more complex plots, consider using `seaborn`, `bokeh`, `plotly`, `altair`, or any other data visualization library.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nDisplay the mean quality of the shopkeeper's items vs the typical quality of each item.\n\n::: {#e7c7bf29 .cell execution_count=44}\n``` {.python .cell-code}\nquality_pd = df_full_pd[[\"item\", \"quality\", \"typical_quality\"]]\nquality_pd.groupby(\"item\").mean().plot(kind=\"bar\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-45-output-1.png){width=558 height=463}\n:::\n:::\n\n\n## 2️⃣ polars\n\nDisplay the mean quality of the shopkeeper's items vs the typical quality of each item.\n\n::: {#90b44648 .cell execution_count=45}\n``` {.python .cell-code}\nquality_pl = df_full_pl.to_pandas()[[\"item\", \"quality\", \"typical_quality\"]]\nquality_pl.groupby(\"item\").mean().plot(kind=\"bar\")\n```\n\n::: {.cell-output .cell-output-display}\n![](index_files/figure-html/cell-46-output-1.png){width=558 height=463}\n:::\n:::\n\n\n```{.python}\n# Similar plot in polars via Altair (not displayed)\n(\n    df_full_pl.group_by(\"item\")\n    .mean()\n    .select(\"item\", \"quality\", \"typical_quality\")\n    .unpivot(index=\"item\")\n    .plot.bar(x=\"item\", y=\"value\", color=\"variable\", column=\"variable\")\n)\n```\n\n\n:::\n\n\n## Dates\n\n### Create a range of dates\n\nThe `pandas` package is great for time series data. It offers valuable functions like `date_range()` or `to_datetime()`. `polars` also has special capabilities for handling time series data, though it seems to me that it expects the user to utilize the `datetime` module more than `pandas`. \n\nAnother difference is that `polars` may return an expression instead of the actual Series of dates by default. This is why you'll see me using `eager=True` to get a Series instead of an expression.\n\nLet's take a look at some of the basic operations with dates.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nMake a range of dates from a specific date (and time) to a specific date (and time).\n\n::: {#e4234b30 .cell execution_count=46}\n``` {.python .cell-code}\npd.date_range(\n    start=\"2025-01-01 00:00\",\n    end=\"2025-01-01 23:00\", \n    freq=\"h\",\n    tz=\"Europe/Prague\"\n)\n```\n:::\n\n\n## 2️⃣ polars\n\nMake a range of dates from a specific date (and time) to a specific date (and time).\n\n::: {#34956d27 .cell execution_count=47}\n``` {.python .cell-code}\npl.datetime_range(\n    start=datetime(2025, 1, 1, 0, 0), \n    end=datetime(2025, 1, 1, 23, 0),\n    interval=\"1h\",\n    eager=True,\n    time_zone=\"Europe/Prague\"\n)\n# Alternative start/end: datetime.fromisoformat(\"2025-01-01 00:00\")\n```\n:::\n\n\n:::\n\n\n\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\nCreate a date range with a specific number of periods. For instance, start at `2025-01-01` and continue 100 days into the future.\n\n::: {#3deea3ed .cell execution_count=48}\n``` {.python .cell-code}\nout_periods = 100\n\npd.date_range(\n    start=\"2025-01-01\", \n    periods=out_periods, \n    freq=\"d\"\n)\n```\n:::\n\n\n## 2️⃣ polars\n\nCreate a date range with a specific number of periods. For instance, start at `2025-01-01` and continue 100 days into the future.\n\n::: {#ab463579 .cell execution_count=49}\n``` {.python .cell-code}\nout_periods = 100\n\npl.date_range(\n    start=date(2025, 1, 1),\n    end=date(2025, 1, 1) + timedelta(days=out_periods - 1),\n    interval=\"1d\",\n    # Returns a Series if True, otherwise returns an expression\n    eager=True\n)\n```\n:::\n\n\n:::\n\n\n### Subset a specific time interval\n\nSuppose we want to take a look at February data in our price table.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#729b1b89 .cell execution_count=50}\n``` {.python .cell-code}\n# Prices in February\nprices_pd[prices_pd.index.month == 2].head()\n```\n\n::: {.cell-output .cell-output-display execution_count=50}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>amulet</th>\n      <th>potion</th>\n      <th>cloak</th>\n      <th>staff</th>\n      <th>scroll</th>\n    </tr>\n    <tr>\n      <th>date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-02-01</th>\n      <td>1200.15</td>\n      <td>45.70</td>\n      <td>441.72</td>\n      <td>1315.41</td>\n      <td>604.27</td>\n    </tr>\n    <tr>\n      <th>2025-02-02</th>\n      <td>828.88</td>\n      <td>55.32</td>\n      <td>526.56</td>\n      <td>1591.24</td>\n      <td>628.25</td>\n    </tr>\n    <tr>\n      <th>2025-02-03</th>\n      <td>774.96</td>\n      <td>47.35</td>\n      <td>515.86</td>\n      <td>1924.56</td>\n      <td>969.40</td>\n    </tr>\n    <tr>\n      <th>2025-02-04</th>\n      <td>842.21</td>\n      <td>53.05</td>\n      <td>522.74</td>\n      <td>2305.17</td>\n      <td>991.64</td>\n    </tr>\n    <tr>\n      <th>2025-02-05</th>\n      <td>1147.03</td>\n      <td>53.27</td>\n      <td>583.07</td>\n      <td>2222.09</td>\n      <td>1529.96</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\n::: {#7de73b32 .cell execution_count=51}\n``` {.python .cell-code}\n# Prices in February\nprices_pl.filter(pl.col(\"date\").dt.month() == 2).head()\n```\n\n::: {.cell-output .cell-output-display execution_count=51}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (5, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>date</th><th>amulet</th><th>potion</th><th>cloak</th><th>staff</th><th>scroll</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2025-02-01</td><td>1200.15</td><td>45.7</td><td>441.72</td><td>1315.41</td><td>604.27</td></tr><tr><td>2025-02-02</td><td>828.88</td><td>55.32</td><td>526.56</td><td>1591.24</td><td>628.25</td></tr><tr><td>2025-02-03</td><td>774.96</td><td>47.35</td><td>515.86</td><td>1924.56</td><td>969.4</td></tr><tr><td>2025-02-04</td><td>842.21</td><td>53.05</td><td>522.74</td><td>2305.17</td><td>991.64</td></tr><tr><td>2025-02-05</td><td>1147.03</td><td>53.27</td><td>583.07</td><td>2222.09</td><td>1529.96</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n### Resampling\n\nIn time series analysis, we often need to change the frequency of our data. For instance, if we have daily data, we may want to look at monthly averages, yearly max values, and so on. \n\nConversely, suppose we want to join a daily and an hourly dataset. In this case, we may need to convert the daily time series to hourly. We can do this by, for example, repeating the daily value for each hour or by using interpolation.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#24daf702 .cell execution_count=52}\n``` {.python .cell-code}\n# Monthly mean from daily data\nprices_pd.resample(\"ME\").mean()\n\n# Upsample daily data to hourly by repeating values\nprices_pd.resample(\"h\").ffill()\n\n# Upsample daily data to hourly by interpolating (linearly)\nprices_pd.resample(\"h\").interpolate(\"linear\")\n```\n:::\n\n\n## 2️⃣ polars\n\n::: {#c51f6d27 .cell execution_count=53}\n``` {.python .cell-code}\n# Monthly mean from daily data\nprices_pl.group_by_dynamic(\n    index_column=\"date\",\n    every=\"1mo\"\n).agg(pl.selectors.numeric().mean())\n\n# Upsample daily data to hourly by repeating values\nprices_pl.upsample(\n    time_column=\"date\",\n    every=\"1h\"\n).select(pl.all().forward_fill())\n\n# Upsample daily data to hourly by interpolating (linearly)\nprices_pl.upsample(\n    time_column=\"date\",\n    every=\"1h\"\n).interpolate()\n```\n:::\n\n\n:::\n\n\n### Group by time intervals\n\nWe can also group data by specific time intervals. For instance, we can calculate the median price of each item in 3-month windows.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n::: {#ed8c46bd .cell execution_count=54}\n``` {.python .cell-code}\nprices_pd.groupby(pd.Grouper(freq=\"3MS\")).median()\n```\n\n::: {.cell-output .cell-output-display execution_count=54}\n```{=html}\n<div>\n<style scoped>\n    .dataframe tbody tr th:only-of-type {\n        vertical-align: middle;\n    }\n\n    .dataframe tbody tr th {\n        vertical-align: top;\n    }\n\n    .dataframe thead th {\n        text-align: right;\n    }\n</style>\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: right;\">\n      <th></th>\n      <th>amulet</th>\n      <th>potion</th>\n      <th>cloak</th>\n      <th>staff</th>\n      <th>scroll</th>\n    </tr>\n    <tr>\n      <th>date</th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n      <th></th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <th>2025-01-01</th>\n      <td>973.755</td>\n      <td>49.995</td>\n      <td>503.050</td>\n      <td>2043.170</td>\n      <td>966.495</td>\n    </tr>\n    <tr>\n      <th>2025-04-01</th>\n      <td>990.040</td>\n      <td>49.340</td>\n      <td>505.000</td>\n      <td>1931.890</td>\n      <td>870.100</td>\n    </tr>\n    <tr>\n      <th>2025-07-01</th>\n      <td>1051.605</td>\n      <td>50.345</td>\n      <td>499.150</td>\n      <td>2005.865</td>\n      <td>850.470</td>\n    </tr>\n    <tr>\n      <th>2025-10-01</th>\n      <td>991.855</td>\n      <td>49.620</td>\n      <td>509.435</td>\n      <td>1997.755</td>\n      <td>851.620</td>\n    </tr>\n  </tbody>\n</table>\n</div>\n```\n:::\n:::\n\n\n## 2️⃣ polars\n\nSome people ([example](https://docs.pola.rs/user-guide/misc/styling/#full-example) in the official docs) format longer `polars` code like this:\n\n::: {#a6356051 .cell execution_count=55}\n``` {.python .cell-code}\n(\n    prices_pl\n    .group_by_dynamic(index_column=\"date\", every=\"3mo\")\n    .agg(pl.selectors.numeric().median())\n)\n```\n\n::: {.cell-output .cell-output-display execution_count=55}\n```{=html}\n<div><style>\n.dataframe > thead > tr,\n.dataframe > tbody > tr {\n  text-align: right;\n  white-space: pre-wrap;\n}\n</style>\n<small>shape: (4, 6)</small><table border=\"1\" class=\"dataframe\"><thead><tr><th>date</th><th>amulet</th><th>potion</th><th>cloak</th><th>staff</th><th>scroll</th></tr><tr><td>date</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td><td>f64</td></tr></thead><tbody><tr><td>2025-01-01</td><td>973.755</td><td>49.995</td><td>503.05</td><td>2043.17</td><td>966.495</td></tr><tr><td>2025-04-01</td><td>990.04</td><td>49.34</td><td>505.0</td><td>1931.89</td><td>870.1</td></tr><tr><td>2025-07-01</td><td>1051.605</td><td>50.345</td><td>499.15</td><td>2005.865</td><td>850.47</td></tr><tr><td>2025-10-01</td><td>991.855</td><td>49.62</td><td>509.435</td><td>1997.755</td><td>851.62</td></tr></tbody></table></div>\n```\n:::\n:::\n\n\n:::\n\n\n\n## Saving data\n\nBoth packages support a large number of output formats and the syntax is similar.\n\n::: {.panel-tabset}\n\n## 1️⃣ pandas\n\n```{.python}\ndf_pd.to_csv(\"file.csv\")\n```\n\n## 2️⃣ polars\n\n```{.python}\ndf_pl.write_csv(\"file.csv\")\n```\n\n:::\n\n\n\n## Sources and further reading\n\nThis guide is mainly based on information from\n\n- <https://docs.pola.rs/>\n- <https://pandas.pydata.org/docs/>\n\nIt's also loosely inspired by Keith Galli's incredible `pandas` tutorial on YouTube\n\n- <https://www.youtube.com/watch?v=vmEHCJofslg>\n\nLet me also mention a neat cheat sheet on going from `pandas` to `polars` on Rho Signal\n\n- <https://www.rhosignal.com/posts/polars-pandas-cheatsheet/>\n\nFinally, for more advanced and extensive coverage of `polars` x `pandas`, I would highly recommend \"Modern Polars\"\n\n- <https://kevinheavey.github.io/modern-polars/>\n\n\n\n\n\n[^pl-style]: For stylistic purposes, let me refer to the Polars package as `polars`.\n\n[^popularity]: 33.4k stars in early May 2025 <https://github.com/pola-rs/polars>.\n\n[^pl-jb]: JetBrains (2023). \"What is Polars?\" on YouTube. <https://www.youtube.com/watch?v=QfLzEp-yt_U>.\n\n[^clone]: See <https://stackoverflow.com/a/78136839>\n\n[^dataset]: See <https://github.com/rnd195/wizard-shop-dataset>\n\n\n\n<br/> [Comment on GitHub](https://github.com/rnd195/rnd195.github.io-comments/issues/3){.btn .btn-secondary title=\"Comment on GitHub\" .bi-chat target=\"_blank\"}\n\n",
    "supporting": [
      "index_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdn.jsdelivr.net/npm/requirejs@2.3.6/require.min.js\" integrity=\"sha384-c9c+LnTbwQ3aujuU7ULEPVvgLs+Fn6fJUvIGTsuu1ZcCf11fiEubah0ttpca4ntM sha384-6V1/AdqZRWk1KAlWbKBlGhN7VG4iE/yAZcO6NZPMF8od0vukrvr0tg4qY6NSrItx\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdn.jsdelivr.net/npm/jquery@3.5.1/dist/jquery.min.js\" integrity=\"sha384-ZvpUoO/+PpLXR1lu4jmpXWu80pZlYUAfxl5NsBMWOEPSjUn/6Z/hRTt8+pR6L4N2\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}