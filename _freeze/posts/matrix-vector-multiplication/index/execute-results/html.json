{
  "hash": "0a0758aeb123569fefd801078d8e6671",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: Visualizing matrix-vector multiplication in bokeh\ndate: '2025-11-14'\ncategories:\n  - python\nimage: thumbnail.png\nother-links:\n  - text: Comment on GitHub\n    icon: chat\n    href: https://github.com/rnd195/rnd195.github.io-comments/issues/5\n    target: _blank\nexecute:\n  freeze: auto\njupyter: python3\n\n# Include the visualize.html bokeh demo\nformat:\n  html:\n    resources: visualize.html\n    css: index.assets/matrix-vector.css\n---\n\n\nAn interactive visualization of two-dimensional matrix-vector multiplication using the `bokeh` library.\n\n![](thumbnail.png){fig-alt=\"A 2 by 2 matrix with values 1 and 2 in the first row and 3 and 4 in the second row, times a 2 by 1 vector with values 5 and 6\"}\n\nIn my attempt at understanding matrix multiplication more intuitively, I stumbled upon a 2011 post on the Stata blog by William Gould.[^post] In this article, Gould illustrates how matrices *transform* space. Specifically, the author lays out a series of images visualizing what happens when we multiply a 2 by 2 matrix by a 2 by 1 vector.\n\nIn this blog post, you'll find an interactive visualization written in Python using the `bokeh` library[^bokeh] that demonstrates this very issue. But to get the full picture (no pun intended), I highly recommend reading Gould's comprehensive and well-paced explanation of the whole setup first.[^post] That being said, to get the most out of the interactive demo that you're going to see later in this blog post, consider this: \n\n1. We can think of the two elements in a 2 by 1 vector as the `x` and `y` coordinates on a standard two-dimensional grid. \n\n2. Multiplying a 2 by 1 vector by a 2 by 2 matrix can simply be drawn as a point being moved from one location to another. \n\nFor example, the multiplication below:\n\n</br>\n$$\n\\begin{pmatrix}\n2.6 & -0.9\\\\\n-1.1 & -2.2\n\\end{pmatrix}\n\\begin{pmatrix}\n10\\\\\n0\n\\end{pmatrix}\n=\n\\begin{pmatrix}\n26\\\\\n-11\n\\end{pmatrix}\n$$\n</br>\n\ncan be drawn as a point going from `x=10` `y=0` (\\*) to `x=26` `y=-11` (\\*\\*). In turn, the 2 by 2 matrix can be thought of as a set of instructions on how to move the point. \n\nNow imagine that you're not looking at a single point, you're looking at a whole bunch of points all being transformed by the same matrix. What would you see? This is what Gould shows in the [fifth figure](https://blog.stata.com/wp-content/uploads/2011/02/fig5.png) of the blog post, and it's what inspired me to create this demo in `bokeh`. Take a look! \n\n:::{.callout-note}\nClicking the image will open the demo.\n:::\n\n<a href=visualize.html>\n<div class=\"my-bokeh-container\">\n<img class=\"img-fluid\" id=\"my-bokeh-demo\" src=\"index.assets/bokeh-demo.png\" alt=\"Bokeh demo image, click to see\">\n<div class=\"my-bokeh-overlay\">Click to open the demo!</div>\n</div>\n</a>\n\n- The green points represent the original `x` and `y` coordinates before being transformed by the 2 by 2 matrix.\n- The purple points represent the `x` and `y` coordinates after being transformed by the 2 by 2 matrix.\n- Using the default settings, the purple line connecting the green (\\*) and purple point (\\*\\*) depicts the transformation in the matrix multiplication example earlier.\n\nThe added benefit of this interactive approach is that you can try out different values in the 2 by 2 matrix to see what happens. I like to imagine the purple field of points as some kind of a stretchy piece of paper, where each slider (i.e., each element of the 2 by 2 matrix) stretches the paper in a different direction, with 2 corners of the paper always pinned down. In addition, the bottom-row sliders appear to warp the paper up and down while the top-row sliders stretch it left and right.\n\nIn fact, a similar space-bending effect can be seen in 3Blue1Brown's videos on linear algebra[^3b1b_1] [^3b1b_2] or part of ChanRT's *Visualize It* project on GitHub.[^vi] By illustrating this transformation using grid lines, 3Blue1Brown stresses that the key property of this act of *\"smooshing around space\"* is that the grid lines are spaced out evenly and stay parallel even after the transformation takes place.\n\nAs a visual learner, I found this approach quite helpful in better understanding the intuition behind matrix multiplication. I hope it's been beneficial to you as well. For those of you interested in how this relates to linear regression, consider finishing Gould's original post on the Stata blog.[^post]\n\n## Source code\n\nWant to generate your own version of the demo? Here's how:\n\n1. Install `uv` <https://docs.astral.sh/uv/#installation>\n2. Copy the script below to a file named, for example, `myscript.py`\n3. Open up a your terminal where you saved the script and type: `uv run myscript.py`\n\n::: {#fbb5bd39 .cell execution_count=1}\n``` {.python .cell-code}\n# /// script\n# dependencies = [\n#   \"bokeh>=3.8.1\",\n#   \"numpy>=2.3.4\",\n# ]\n# ///\n\nimport bokeh.plotting as bp\nimport bokeh.models as bm\nimport bokeh.layouts as bl\nimport bokeh.io as bi\nimport numpy as np\n\n\nclass Params:\n    DEFAULT_MATRIX = np.array([[2.6, -1.1], [-0.9, -2.2]])\n    OUT_FILE = \"visualize.html\"\n\n\n#### PREPARE DATA ####\n# Precalculate values to get every combination of [0, 1, 2, ..., 10] as a 2x1 vector\nx_coords = [x for _ in range(11) for x in range(11)]\ny_coords = [y for y in range(11) for _ in range(11)]\n\n# Get an initial transformed matrix for each combination of x and y coordinates\nx_coords_t, y_coords_t = Params.DEFAULT_MATRIX @ np.array([x_coords, y_coords])\n\n\n#### CREATE DATA SOURCES ####\nsrc_transform = bm.ColumnDataSource(\n    data=dict(\n        x=x_coords_t,\n        y=y_coords_t\n    )\n)\nsrc_anchor = bm.ColumnDataSource(\n    data=dict(\n        x_anchor=[x_coords_t[10]],\n        y_anchor=[y_coords_t[10]],\n    )\n)\nsrc_line = bm.ColumnDataSource(\n    data=dict(\n        x_line=[x_coords[10], x_coords_t[10]],\n        y_line=[y_coords[10], y_coords_t[10]]\n    )\n)\n\n#### PREPARE FIGURE ####\nfig = bp.figure(height=600, width=620)\n# Original untransformed values\nfig.scatter(\n    x=x_coords,\n    y=y_coords,\n    fill_color=\"lightseagreen\",\n    line_color=\"lightseagreen\",\n    size=6,\n    legend_label=\"Original\"\n)\n# Line that connects anchors\nfig.line(\n    x=\"x_line\",\n    y=\"y_line\",\n    line_color=\"mediumpurple\",\n    source=src_line\n)\n# Point anchor on the original data\nfig.scatter(\n    x=x_coords[10],\n    y=y_coords[10],\n    fill_color=\"white\",\n    line_color=\"lightseagreen\",\n    line_width=2,\n    size=9\n)\n# Transformed values\nfig.scatter(\n    x=\"x\",\n    y=\"y\",\n    source=src_transform,\n    fill_color=\"mediumpurple\",\n    line_color=\"mediumpurple\",\n    size=6,\n    legend_label=\"Transformed\"\n)\n# Point anchor on the transformed data\nfig.scatter(\n    x=\"x_anchor\",\n    y=\"y_anchor\",\n    source=src_anchor,\n    fill_color=\"white\",\n    line_color=\"mediumpurple\",\n    line_width=2,\n    size=9\n)\n\n\nfig.xaxis.axis_label = \"x coordinates\"\nfig.yaxis.axis_label = \"y coordinates\"\nfig.legend.location = \"top_left\"\nfig.legend.background_fill_alpha = 0.3\n\n#### INTERACTIVITY ####\n# Sliders to change the values within the matrix - start with defaults from the blog post\nslider1 = bm.Slider(start=-5, end=5, value=Params.DEFAULT_MATRIX[0][0], step=0.1)\nslider2 = bm.Slider(start=-5, end=5, value=Params.DEFAULT_MATRIX[0][1], step=0.1)\nslider3 = bm.Slider(start=-5, end=5, value=Params.DEFAULT_MATRIX[1][0], step=0.1)\nslider4 = bm.Slider(start=-5, end=5, value=Params.DEFAULT_MATRIX[1][1], step=0.1)\n\njs = \"\"\"\n// --- PREPARE INPUTS ---\n// snake_case - Python objects, camelCase - JS objects\n\nconst xCoordsOut = [];\nconst yCoordsOut = [];\n\nconst s1 = slider1.value.toFixed(1);\nconst s2 = slider2.value.toFixed(1);\nconst s3 = slider3.value.toFixed(1);\nconst s4 = slider4.value.toFixed(1);\n\nconst inputMx = [[s1, s2], [s3, s4]];\n\n// --- CALCULATE ---\n// 2x1 vector times 2x2 matrix is calculated each iteration\nfor (let index = 0; index < x_coords.length; index++) {\n    xCoordsOut.push(x_coords[index] * inputMx[0][0] + y_coords[index] * inputMx[1][0]);\n    yCoordsOut.push(x_coords[index] * inputMx[0][1] + y_coords[index] * inputMx[1][1]);\n}\n\n// --- OUTPUTS ---\nsrc_transform.data = { \n    x: xCoordsOut, \n    y: yCoordsOut \n};\nsrc_anchor.data = { \n    x_anchor: [xCoordsOut[10]], \n    y_anchor: [yCoordsOut[10]] \n};\nsrc_line.data = { \n    x_line: [src_line.data[\"x_line\"][0], xCoordsOut[10]],\n    y_line: [src_line.data[\"y_line\"][0], yCoordsOut[10]] \n};\n\"\"\"\n\ncallback = bm.CustomJS(\n    args=dict(\n        src_transform=src_transform,\n        src_anchor=src_anchor,\n        src_line=src_line,\n        x_coords=x_coords,\n        y_coords=y_coords,\n        slider1=slider1,\n        slider2=slider2,\n        slider3=slider3,\n        slider4=slider4\n    ),\n    code=js\n)\n\nslider1.js_on_change(\"value\", callback)\nslider2.js_on_change(\"value\", callback)\nslider3.js_on_change(\"value\", callback)\nslider4.js_on_change(\"value\", callback)\n\nbutton_default = bm.Button(label=\"Default values\")\nbutton_default.js_on_event(\n    \"button_click\",\n    bm.SetValue(slider1, \"value\", Params.DEFAULT_MATRIX[0][0]),\n    bm.SetValue(slider2, \"value\", Params.DEFAULT_MATRIX[0][1]),\n    bm.SetValue(slider3, \"value\", Params.DEFAULT_MATRIX[1][0]),\n    bm.SetValue(slider4, \"value\", Params.DEFAULT_MATRIX[1][1])\n)\nbutton_zero = bm.Button(label=\"Zero matrix\")\nbutton_zero.js_on_event(\n    \"button_click\",\n    bm.SetValue(slider1, \"value\", 0),\n    bm.SetValue(slider2, \"value\", 0),\n    bm.SetValue(slider3, \"value\", 0),\n    bm.SetValue(slider4, \"value\", 0)\n)\nbutton_diag_one = bm.Button(label=\"Identity matrix\")\nbutton_diag_one.js_on_event(\n    \"button_click\",\n    bm.SetValue(slider1, \"value\", 1),\n    bm.SetValue(slider2, \"value\", 0),\n    bm.SetValue(slider3, \"value\", 0),\n    bm.SetValue(slider4, \"value\", 1)\n)\n\n\n#### LAYOUT AND EXPORT ####\ntitle = bm.Div(text=\"\"\"\n<h2>Matrix-vector multiplication demo</h2>\n<p>\nPart of the <a href=\"https://rnd195.github.io/posts/matrix-vector-multiplication/\">\n\"Visualizing matrix-vector multiplication in bokeh\"</a> blog post by rnd195 (CC BY 4.0).\n</p>\n</br>\n\"\"\")\n\nout = bl.layout(\n    bl.column(\n        title,\n        bl.row(button_default, button_zero, button_diag_one),\n        bl.row(\n            bl.column(slider1, slider2),\n            bl.column(slider3, slider4),\n        ),\n        fig\n    ),\n    margin=(10, 20, 20, 20)\n)\nbp.curdoc().theme = \"dark_minimal\"\nbi.output_file(\n    Params.OUT_FILE,\n    title=\"Matrix-vector multiplication\",\n    mode=\"inline\"\n)\nbp.save(out)\nprint(f\"HTML file saved: {Params.OUT_FILE}\")\n```\n:::\n\n\n[^post]: Gould, W. (2011). Understanding matrices intuitively, part 1. Stata blog. URL: <https://blog.stata.com/2011/03/03/understanding-matrices-intuitively-part-1/>\n[^bokeh]: <https://docs.bokeh.org/en/latest/>\n[^vi]: ChanRT. Visualize It. GitHub. URL: <https://visualize-it.github.io/linear_transformations/simulation.html>\n[^3b1b_1]: 3Blue1Brown (2016). Linear transformations and matrices | Chapter 3, Essence of linear algebra. YouTube. URL: <https://www.youtube.com/watch?v=kYB8IZa5AuE>\n[^3b1b_2]:3Blue1Brown (2016). Matrix multiplication as composition | Chapter 4, Essence of linear algebra. YouTube. URL: <https://www.youtube.com/watch?v=XkY2DOUCWMU>\n\n\n\n\n<br/> [Comment on GitHub](https://github.com/rnd195/rnd195.github.io-comments/issues/5){.btn .btn-secondary title=\"Comment on GitHub\" .bi-chat target=\"_blank\"}\n\n",
    "supporting": [
      "index_files\\figure-html"
    ],
    "filters": [],
    "includes": {}
  }
}